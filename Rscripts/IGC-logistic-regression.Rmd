```{r}
library(valr)
merged_igc <- merged_df %>%
    rename(
        `chrom` = "#reference_name.liftover",
        start = reference_start.liftover,
        end = reference_end.liftover,
    )
merged_igc$pvalue <- get_pvalues_from_igc(merged_igc)

all_sd <- rbind(SEDEF_V1.1, SEDEF_V1.1_LOWID, fill = TRUE) %>%
    rename(
        `chrom` = "chr",
    )
flat_all_sd <- as.data.table(reduce(toGRanges(all_sd)))
sum(flat_all_sd$end - flat_all_sd$start) / 1e6

hap_cov <- fread("data/haplotype_coverage_bed_graph.bed")
colnames(hap_cov) <- c("chrom", "start", "end", "hap_coverage")
```


# make 10 SD windows 
```{r}
merge_into_windows <- function(df, n_win = 10) {
    df[, bases := end - start]
    df[,
        sample_window := rep(1:.N,
            each = n_win,
            length.out = .N
        ),
        by = list(chrom, region, hap)
    ]

    grouped_windows <- df[,
        .(
            start = min(start),
            end = max(end),
            per_div = mean(per_div),
            bases = sum(bases),
            num_snv = sum(num_snv),
            n_windows = .N
        ),
        by = list(chrom, region, hap, sample_window)
    ] %>%
        filter(
            end - start > 0.9 * bases & end - start < 1.1 * bases
        )
    grouped_windows[, SNVsPer10k := 10e3 * num_snv / bases]
    grouped_windows
}
sd_windows <- snv_windows[region == "SD"] %>%
    mutate(width = end - start) %>%
    rename(
        `chrom` = "#chr",
    )
sd_windows_10 <- merge_into_windows(sd_windows, n_win = 10)
mean(sd_windows_10$end - sd_windows_10$start == 10e3)
dim(sd_windows_10) / 1e6
dim(sd_windows) / 1e6
merged_sd_windows <- sd_windows_10[,
    .(
        hap_coverage = .N,
        num_snv = sum(num_snv),
        bases = sum(bases)
    ),
    by = list(chrom, start, end, region)
]
merged_sd_windows[, SNVs_per_10 := num_snv / bases * 10e3]
merged_sd_windows
mean(merged_sd_windows$SNVs_per_10)
```

# load TMRCA
```{r}
tmrca <- fread("data/TMRCA/TMRCA.tbl")
```
# add igc or other info to SDs
```{r}
add_sd_info_to_df <-
    function(df,
             add_hap = FALSE,
             add_igc = FALSE,
             add_tmrca = TRUE,
             min_pvalue = 0.05) {
        columns <- c(colnames(df), "hap_coverage", "n_unique_igc", "AT", "GC", "TMRCA")
        if (add_hap) {
            df <- df %>%
                bed_intersect(., hap_cov, suffix = c("", ".hap")) %>%
                group_by_at(vars(one_of(columns))) %>%
                summarise(hap_coverage = mean(hap_coverage.hap)) %>%
                as.data.table()
        }
        print(dim(df)) / 1e6
        if (add_tmrca) {
            df <- df %>%
                bed_intersect(., tmrca, suffix = c("", ".tmrca")) %>%
                group_by_at(vars(one_of(columns))) %>%
                summarise(
                    TMRCA = mean(TMRCA.tmrca),
                    AT = mean(AT.tmrca),
                    GC = mean(GC.tmrca)
                ) %>%
                data.table()
        }
        print(dim(df)) / 1e6
        print(colnames(df))
        if (add_igc) {
            counts <- as.data.table(
                findOverlaps(
                    toGRanges(df[, c("chrom", "start", "end")]),
                    toGRanges(merged_igc[pvalue <= min_pvalue, c("chrom", "start", "end")])
                )
            ) %>%
                group_by(queryHits) %>%
                summarise(N = n())
            df$n_unique_igc <- 0
            df[counts$queryHits]$n_unique_igc <- counts$N
        }
        print(dim(df))
        print(colnames(df))
        df %>%
            bed_intersect(., all_sd, suffix = c("", ".SD")) %>%
            group_by_at(vars(one_of(columns))) %>%
            summarise(
                aln_len = mean(aln_len.SD),
                max_aln_len = max(max_len.SD),
                fracMatch = mean(fracMatch.SD),
                maxFracMatch = max(fracMatch.SD),
                sumFracMatch = sum(fracMatch.SD),
                SD_count = n()
            ) %>%
            data.table()
    }
merged_sd_windows_info <- add_sd_info_to_df(
    merged_sd_windows,
    add_igc = TRUE,
    add_tmrca = FALSE,
    min_pvalue = 0.1
)
merged_sd_windows_info$n_unique_igc_per_hap <-
    merged_sd_windows_info$n_unique_igc / merged_sd_windows_info$hap_coverage

merged_sd_windows_info$has_igc <- factor(
    merged_sd_windows_info$n_unique_igc_per_hap > 0
)

merged_sd_windows_info$sd_divergence <-
    1 - merged_sd_windows_info$maxFracMatch
```

```{r}
# note: linear mixed effects model
# note: nural net, might be predictive.
model <- lm(
    SNVs_per_10 ~
    (
        scale(log(SD_count)) +
            scale(sd_divergence) +
            scale(n_unique_igc) +
            scale(TMRCA) +
            scale(GC)
    )^2,
    data = merged_sd_windows_info
)
summary(model)
```



```{r}
merged_sd_windows_info %>%
    # filter(pvalue <= 0.05) %>%
    ggplot(aes(x = 100 * maxFracMatch)) +
    geom_histogram(binwidth = 0.25) +
    scale_y_continuous("# of IGC events (p < 0.05)", labels = comma) +
    scale_x_continuous(
        labels = comma,
        "Maximum percent identity of overlapping SD",
    ) +
    coord_cartesian(xlim = c(90, NA)) +
    theme_minimal_grid()
ggsave("tmp.pdf")
```

```{r}
merged_sd_windows_info %>%
    # filter(pvalue <= 0.05) %>%
    ggplot(aes(x = 100 * maxFracMatch, y = SNVs_per_10)) +
    geom_hex() +
    # stat_cor() +
    geom_smooth(method = "lm", se = FALSE) +
    scale_y_continuous(
        "# SNVs per 10 kbp",
        labels = comma,
        trans = "log10"
    ) +
    scale_x_continuous(
        labels = comma,
        "Highest identity overlapping SD",
    ) +
    scale_fill_distiller("", palette = "Spectral", trans = "log10") +
    # coord_cartesian(xlim = c(90, NA)) +
    theme_minimal_grid()
ggsave("tmp.pdf")
ggsave("figures/SNVsPer10kbp_vs_SDidentity.pdf")
```
```{r}
model <- lm(
    n_unique_igc / hap_coverage ~
    (log(SD_count) +
        log(1 - maxFracMatch + 1 / max_aln_len) +
        max_aln_len +
        SNVs_per_10
    )^2,
    data = merged_sd_windows_info[n_unique_igc > -0]
)
summary(model)

merged_sd_windows_info %>%
    filter(n_unique_igc > 0) %>%
    filter(sd_divergence > 0) %>%
    ggplot(aes(x = 100 * (sd_divergence), y = n_unique_igc / hap_coverage)) +
    geom_hex(bins = 40) +
    stat_cor() +
    geom_smooth(method = "lm", se = FALSE) +
    scale_fill_distiller("", palette = "Spectral", trans = "log10") +
    scale_x_continuous("% divergence between SD paralogs", trans = "log10", label = comma) +
    scale_y_continuous("# unique IGC events per 1 kbp window per haplotype",
        # trans="log10",
        label = comma
    ) +
    annotation_logticks(side = "b") +
    theme_minimal_grid()
ggsave("tmp.pdf")
```




# merge igc and SD data
```{r}
columns <- c(colnames(merged_igc), "hap_coverage")

merged_igc_with_sd <- merged_igc %>%
    bed_intersect(., hap_cov, suffix = c("", ".hap")) %>%
    group_by_at(vars(one_of(columns))) %>%
    summarise(hap_coverage = mean(hap_coverage.hap)) %>%
    ungroup() %>%
    bed_intersect(., all_sd, suffix = c("", ".SD")) %>%
    group_by_at(vars(one_of(columns))) %>%
    summarise(
        aln_len = mean(aln_len.SD),
        max_aln_len = max(max_len.SD),
        fracMatch = mean(fracMatch.SD),
        maxFracMatch = max(fracMatch.SD),
    ) %>%
    data.table()
dim(merged_igc_with_sd)
```
